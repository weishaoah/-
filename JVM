1. Java内存区域（运行时数据域）
   线程私有:程序计数器、虚拟机栈、本地方法栈
   线程共享：堆、方法区和直接内存
   程序计数器：唯一不会出现OOM的内存区域，字节码解释器通过改变程序计数器指向下一条读取的指令。同时多线程时，每个线程都有一个独立的计数器来确保恢复。
   虚拟机栈：由一个个栈帧组成，每个栈帧都拥有局部变量表（基本数据类型和引用类型）、操作数栈、动态链接和方法出口信息。可能会出现StackOverFlowError和OOM。
   本地方法栈：和虚拟机栈相似，只是虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法栈是为虚拟机使用到的Native方法（java调用的非java代码的接口）服务。
   
   堆（heap）：内存中最大的一块，所有线程共享，用于存放对象实例。而且JAVA堆是GC管理的主要区域。
   方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。（其中一部分叫运行时常量池，用于存放编译期生成的各种字面量和符号引用）
   注：JDK1.7以后JVM已经在堆中开辟了一块用于存放运行时常量池。
   Class文件结构中，最开始的4个字节用于存放魔数确定一个文件能否被JVM接受，然后是版本号、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存储在编译
   期间生成的各种字面量和符号引用，字面量即字符串、final类型的常量值等，符号引用即用于描述引用对象的信息（其实就是带有类型（tag）/结构（符号间引用层次）的字符串）。
   运行时常量池：而上述的常量池信息会在类加载后进入运行时常量池存放。同时运行期间也可能将新的常量放入池中。
2. JVM的体系结构
   （1）类的生命周期：加载--验证--准备--解析--初始化--使用--卸载
   加载过程：JVM在遇到一个新的类时，会先去方法区中找有没有相应的类的class文件存在，如果有直接使用，如果没有则需要将其加载到方法区
            加载顺序：先加载非静态内容，再加载静态内容；非静态内容加载到方法区下的非静态区域，而静态内容会加载到静态区域中，静态加载完成后会对所有的静态变量
            进行默认初始化，然后进行显示初始化，再执行静态代码块。
   类加载器：基于双亲委托、可见性和单一性。类加载器负责加载文件系统、网络或者其他来源的类文件。三种默认加载器：Bootstrap类加载器、Extension加载器和Application类加载器
            Bootstrap类加载器：负责加载rt.jar中的JDK类文件，是所有类加载器的父加载器。
            Extension类加载器：将加载类的请求先委托给其父加载器即Bootstrap，如果没有成功加载再从jre/lib/ext目录下或者java.ext.dirs系统属性定义的目录下加载类。
            Application类加载器：负责从classpath环境变量中加载某些应用相关的类。是Extension类加载器的子加载器。
            双亲委托机制：如果一个类加载器收到加载请求，首先不会尝试加载这个类，而是将这个请求委派给父类加载器完成。只有当父加载器在自己的搜索范围内找不到指定类时，
            即抛出异常ClassNotFoundException，子加载器才会尝试自己去加载。主要是防止核心API库被随意篡改，一定程度上保证了代码的安全性。
            
            可见性：子类加载器可以看到父类加载器加载的类，反之不行。
            单一性：父加载器加载过的类不能被子加载器加载第二次。
   显式加载类：Class.forName
   自定义加载器：继承ClassLoader类，重写findClass方法。
   验证：确保Class文件的字节流中包含的信息符合当前VM的要求。
   准备：为类变量分配内存并设置类变量初始值（初始零值）。
   解析：虚拟机将常量池中的符号引用替换为直接引用。
   延迟加载和动态连接：其实都是在执行时才加载需要的类。
   （2）对象创建
   类加载--分配内存--初始化零值--设置对象头--执行init方法
   分配内存：为新生对象分配内存。主要有“指针碰撞”和“空闲列表”两种方式。
            内存分配的并发问题：CAS+失败重试机制或者TLAB机制（为每个线程预先在Eden区分配一块内存，当TLAB中的内存用尽时才用上述的CAS分配内存）
   （3）对象的内存布局：分为三块，对象头，实例数据和对齐填充
   对象头（Header）：第一部分用于存储对象自身的运行数据，包含hashcode，GC分代年龄，锁状态标志位，线程持有的锁，偏向线程id等，这部分称为Mark Word
                   第二部分是类型指针，即对象指向它的类元数据的指针，即通过这个指针确定对象是哪个类的实例。
   实例数据（Instance Data）：对象真正存储的有效信息。
   对齐填充：占位符。
