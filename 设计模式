1. 原则：
单一性原则（SRP）：就一个类而言，应该仅有一个引起它变化的原因
开放-封闭原则：对扩展开放，对修改封闭
依赖倒转原则：（1）高层模块不应该依赖低层模块，两个都应该依赖抽象
             （2）抽象不应该依赖细节，细节应该依赖抽象
里氏替换原则：一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是，在软件里面，把父类都替换成
             它的子类，程序的行为没有变化。（子类必须能够替换掉他们的父类型）
2. 工厂模式：为创建对象提供过渡接口
  （1）分类：简单工厂模式，工厂方法模式，抽象工厂模式
  （2）简单工厂模式：又称静态工厂方法模式，用于定义一个用于创建对象的接口。
       组成：工厂类角色，抽象产品角色，具体产品角色，返回类型是抽象产品类型，static修饰。
       //抽象产品角色
       public interface Car{
        public void drive();
       }
       //具体产品类
       public class Benz implements Car{
          public void drive(){
            syso("Driving Benz");
          }
       }
       public class BMW implements Car{
          public void drive(){
              ....
          }
       }
      //工厂类
      public class Driver{
          //工厂方法
          public static Car driveCar(String s) throws Exception{
              if(s.equals("Benz")
                  return new Benz();
              else if...
          }
      }
     //暴发户（用户）
     public class Magnage{
        main(){
            try{
                Car car = Driver.driveCar("Benz");
                car.drive();
                ...
            }
        }
     }
     (3)工厂方法模式：和简单工厂模式相比，它去掉了其工厂方法中的静态属性，使得它可以被子类继承。
     使用继承自抽象工厂角色的多个子类来代替简单工厂中的”上帝类“。
     (4)抽象工厂模式：给客户端提供一个接口，可以创建多个产品族中的产品对象而且使用抽象工厂模式还需要满足一下条件：
                    系统中有多个产品族，而系统一次只能消费其中一族产品
                    角色：抽象工厂，具体工厂，抽象产品，具体产品
3. 单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点。这里的单例，通常是指那些本质上具有唯一性的系统组件，如文件系统、资源管理器等。
   （1）饿汉式:在类的内部定义一个private内部实例
        public class Singleton{
            private static Singleton instance = new Singletion();
            //将构造函数设为私有
            private Singleton(){
            }
            //静态工厂方法
            public static Singleton getInstance(){
                return instance; 
            }
        }
        
     (2)懒汉式：防止多线程中产生多个实例
     public class Singleton{
        private static Singleton instance = null;
        //设置为私有的构造函数
        private Singleton(){}
        //静态工厂方法
        public static synchronized Singleton getInstance(){
            if(instance == null)
                instance = new Singleton();
            return instance;
        }
     }
     （3）双重检测：
     public class Singleton{
         private static Singleton instance = null;
         private Singleton(){}
         //双重检查
         public static Singleton getInstance(){
            if(instance == null){
                synchronized(this.class){
                    if(instance == null)
                        instance = new Singleton();
                }
            }
            return instance;
         }
     }
