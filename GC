
1.为什么要进行GC？
如果不进行GC内存迟早被消耗空。
2. JVM的堆内存分配与回收
堆内存分代，分为新生代、老年代和永久代，在JDK1.8中移除了永久代，取而代之的是元空间（使用的是物理内存）
其中新生代又分为Eden+Survivor1区+Survivor2区。
分配策略：目前主流的GC都采用分代回收算法（1）对象优先分配在Eden区。当eden区没有足够的空间时虚拟机会发起一次Minor GC测试一下。
         当Eden区没有足够的内存时，进行Minor GC判断是否能将Eden区的对象存入Survivor区，如果不能则通过分配担保机制将其存入老年代。
注：Minor GC是指发生在新生代的GC动作，非常频繁，回收速度快。
   Major GC是指发生在老年代的GC，速度比Minor GC慢。
         （2）大对象（需要大量连续内存空间的对象）直接进入老年代，这是为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率。
         （3）长期存活的对象将进入老年代。VM给每个对象有一个对象年龄（Age）计数器。如果对象在Eden出生并经过一次Minor GC后仍然存活，
              并能被Survivor容纳，将被移动到Survivor并将对象年龄设为1，对象在Survivor中每熬过一次Minor GC年龄就增加1岁，当达到一个
              threshold时会被晋升到老年代。（当Survivor中相同年龄对象大于空间的一半，则这部分直接进入老年代）
3. 哪些内存需要回收？即那些已经死亡（无效）的对象（不能再被任何途径使用）。
如何判断一个对象已经无效？（1）引用记数法：给对象添加一个引用计数器，每一次引用就+1，引用失效-1，但是他很难解决相互循环引用的问题。
                        （2）可达性分析：通过一系列的称为“GC Roots”的对象作为起点，从这些节点往下搜索，节点走过的路径称为引用链，当一个对象
                        没有任何引用链相恋的话，则证明此对象不可用
注：哪些对象可以作为GC Roots呢？（1）虚拟机栈（栈帧中的局部变量区，即局部变量表）中引用的对象
                              （2）方法区中的类静态属性引用的对象
                              （3）方法区中常量引用的对象
                              （3）本地方法栈中JNI（Native方法）引用的对象。
   引用的分类：（1）强引用：GC不会回收，当内存空间不足JVM会抛出OOM的错误使程序异常终止。
              （2）软引用（SoftReference）：如果内存空间够就不回收，内存空间不够就回收。可用于实现高速缓存
              （3）弱引用（WeakReference）：非必需对象，当下一次GC时，无论内存空间是否足够都会回收
              （3）虚引用：GC时就会收到系统通知。
   方法区回收：主要回收废弃常量和无用的类。判断无用的类的条件：类的所有实例已经被回收，加载该类的ClassLoader已经被回收，类对应的java.lang.Class对象
              没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
   不可达的对象并非“非死不可”：要宣告一个一个对象死亡，至少要经历两次标记过程：可达性分析中不可达的对象被第一次标记并进行一次筛选，筛选条件是此对象是否
                             有必要执行finalize方法，若对象没有覆盖finalize方法或finalize方法已经被VM调用过，VM则认为没必要执行。
                             被判定为需要执行的对象会放在一个队列中进行二次标记，除非该对象与引用脸上任何一个对象建立关联，否则就会被真的回收。
   finalize方法：是Object中的方法，在GC将要回收对象所占内存之前调用，即当一个对象被VM宣告死亡时先调用finalize方法，让它处理生前最后的事情（同时对象可以
   通过这个方法摆脱死亡的命运）
4. GC算法
   （1）标记-清除（Mark-Sweep）算法：分为标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收。效率不高，同时会有大量的不连续内存碎片。
   （2）复制（Copying）算法：为了解决效率问题。将可用的内存分为两块，每次只用一块，当一块内存完了，将还存活的对象复制到另一块上面，然后把已经使用过的空间一次性清理。
   注：缺点就是内存缩小为原来的一半。如今的商用虚拟机都采用这种方法来回收新生代，回收时会将Eden和Survivor中存活的对象一次性复制到另一块Survivor中。
   （3）标记-整理（Mark-Compact）算法：又叫标记-压缩算法，让所有存活对象都向一端移动，然后清理掉边界以外的内存。
   （4）分代收集算法：新生代采用复制算法，而老年代采用标记-清理或者标记-整理算法。
5. 垃圾回收器：
   新生代：Serial收集器：采用复制算法的单线程收集器。它依然是VM运行在Client模式下的默认新生代收集器。（需要STW，停顿时间长）
          ParNew收集器：Serial收集器的多线程版，是Server模式下的VM首选新生代收集器。
          Parallel Scavenge收集器：目标是达到一个可控制的吞吐量（CPU用于运行用户代码时间与CPU消耗时间的比值）。高吞吐量可以高效利用CPU时间，适合后台计算，
          而停顿时间短则是用于用户交互。
   老年代：Serial Old收集器：Serial的老年代版本。
          Parallel Old收集器：Parallel Scavenge的老年代版本，使用多线程+标记-整理算法。
          CMS（Concurrent Mark Sweep）收集器：目标是获取最短回收停顿时间，使用的是标记-清除算法，适合注重用户体验的应用。
          分为四步：初始标记（标记GCRoots能直接关联到的对象，时间短，STW）、并发标记（进行可达性分析过程，时间很长）、重新标记（修正并发标记期间因用户程序
          继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长，STW）、并发清除（回收内存空间，时间很长）
          G1收集器：替换掉JDK1.5中发布的CMS收集器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。
            使用G1，Java堆的内存布局就与其他收集器有很大差别，将整个Java堆分为多个大小相等的独立区域(Region)，虽然还有新生代和老年代的区别，但是不再是物理隔离。
            在后台维护一个优先列表，每次跟据允许的收集时间，优先回收价值最大的Region。
            特征：并行与并发。能充分利用CPU、多核环境下的硬件优势，使用多个CPU来缩短STW停顿时间。
                 分代收集
                 空间整合
                 可预测的停顿
