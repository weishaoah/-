一、依图科技
1. HashMap的底层原理：JDK1.7以前是数组（Entry数组）+单链表链表。对于一个对象，首先根据其hashcode计算其hash值，然后找到在数组中的位置，进行插入。
   结构：static class Entry<K, V> implements Map.Entry<K, V> {
             final K key;
             V value;
             Entry<K, V> next;
             final int hash;
             }
        计算hash值是抖动函数，同时设定了负载因子和初始容量，当hashmap的容量达到负载因子*初始容量时需要进行扩容（resize）。
        抖动函数：h ^= (h >>> 20) ^ (h >>> 12);
        return h ^ (h >>> 7) ^ (h >>> 4);
        查找在数组中的位置：h&（length-1）
        主要方法：put和get方法
        put方法：首先查找其对应的hash值和index，如果该位置为空，则直接插入，若不为空，寻找相等的key，如果有则替换，否则插入到链表尾部。同时需要考虑
                扩容的情况
        get方法：直接获取
        为什么数组的长度要是2的整次幂？首先其计算位置的方法为h&（length-1），这样可以保证数据的均匀分布，从而减少哈希冲突。
                                    另外这样可以保证在扩容时，只有最高位的不同，因此可以保证散列均分分布。
        如何减少哈希冲突？2的整次幂，抖动函数，尽可能使用封装类，他们是不可变的，有固定的hash值和length。
        JDK1.8使用的是数组+链表+红黑树，同时抖动函数发生变化，直接高十六位和低十六位进行异或。
        1.7和1.8中的区别：
        （1）数据结构：前者是数组+链表，后者是数组+链表+红黑树。当链表深度达到阈值（8）时就将链表转化为红黑树。同时插入方法为尾插法，而前者是头插法，会导致死循环。
        （2）抖动函数的不同
        （3）扩容后的数据存储位置的计算不同：前者是直接将hash值与扩容后的二进制数进行&操作，而后者则是判断新增的参与运算的位是0还是1.
  注：重写equals方法为什么一定要重写hashcode方法？因为在java编程中规定，如果两个对象的equals判断为真，那么他们的hashcode值一定相同。
  线程不安全：为什么？多线程时采用头插法可能会导致死循环
  允许null键和值
  HashTable：不允许null值，线程安全，初始容量11，扩容2x+1，计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length，效率较低。rehash方法
2. TreeMap底层实现：
红黑树基本概念：
五个要求：（1）每个节点只能是红色或者黑色（2）根节点是黑色的（3）每个叶节点（NIL节点，空节点）都是黑色的（4）一个节点如果是红色的，其两个字节点都是黑色的。
（5）从任一节点到其每个叶子节点的所有路径上的黑色节点数目相同。
基本操作：旋转和着色。
TreeMap的底层结构是红黑树，同时是有序的，因为其内部有一个Comparator的比较器，可以实现比较和排序。
put方法
put：分为两步，构建二叉排序数和平衡二叉树。
3.JVM
Java的内存区域：分为堆和栈，栈（私有）中包括PC，虚拟机栈（栈帧，局部变量表，操作数，动态链接等信息）和本地方法栈（Native方法，java调用的非java代码）
堆（共享）主要包含堆（创建实例对象）、方法区（存储已被VM加载的类信息、常量、静态变量和即时编译信息），运行时常量池（将方法区中的常量池内容加载到运行时常量池
主要是字面量和符号引用，其中符号引用主要是tag和index的字符串结构）
类的生命周期：类加载--验证--准备--解析--初始化--使用--卸载。
加载：双亲委派机制，单一性和可见性。Boostrap加载器，Extension加载器和Application加载器，也可以自定义加载器，需要重写findClass方法。
验证：根据class文件中的magic number来判断是否符合当前VM的要求。
准备：为类变量分配内存并设置初始值（初始零值）
解析：将符号引用转化为直接引用。
对象创建过程：类加载--分配内存--初始化零值--设置对象头--执行init方法
4.GC机制
首先是判断哪些对象需要被回收（那些不会再被引用的对象）
判断方法：引用记数法，但是如果存在循环引用就不行了
可达性分析：从GC roots对象作为起点，向下搜索，走过的路径称为引用链，如果有一个对象不在引用链上就判断为不可用
哪些对象可以作为GC roots：虚拟机栈的局部变量表中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中Native方法引用的对象
引用的分类：强引用，软引用，弱引用，虚引用
GC区内存分代:新生代和老年代还有永久代，之后叫元数据空间，新生代又分为Eden，Survivor1区，Survivor2区。
分配策略：（1）对象优先分配在Eden区，如果Eden区没有足够的空间，会进行一次MinorGC将一部分数据搬运到Survivor区，如果不能存入则通过分配担保机制将其存入老年代。
         （2）大对象直接进入老年代
         （3）长期存活的对象进入老年代（Age计数器）
GC算法：（1）标记-清除
       （2）复制
       （3）标记-整理
       （4）分代：新生代使用复制算法，老年代使用标记-整理算法
GC收集器：新生代（1）Serial：单线程的复制算法
               （2）ParNew：多线程的复制算法，关注停顿时间，适合用户交互
               （3）Parallel Scavenge：复制算法，关注的是控制系统运行的吞吐量，适用于后台计算
         老年代：（1）SerialOld
                 (2)ParOld:parallel scavenge
                （3）CMS：注重缩短停顿时间，使用的是标记-清除算法
                初始标记--并发标记（GC roots tracing）--重新标记--并发清除
                缺点：对CPU资源敏感，可能产生浮动垃圾，使用的是标记-清除算法，产生内存碎片
                （4）G1：堆内存布局就不同，分为region，里面有新生代和老年代的区别。
         
