一、依图科技
1. HashMap的底层原理：JDK1.7以前是数组（Entry数组）+单链表链表。对于一个对象，首先根据其hashcode计算其hash值，然后找到在数组中的位置，进行插入。
   结构：static class Entry<K, V> implements Map.Entry<K, V> {
             final K key;
             V value;
             Entry<K, V> next;
             final int hash;
             }
        计算hash值是抖动函数，同时设定了负载因子和初始容量，当hashmap的容量达到负载因子*初始容量时需要进行扩容（resize）。
        抖动函数：h ^= (h >>> 20) ^ (h >>> 12);
        return h ^ (h >>> 7) ^ (h >>> 4);
        查找在数组中的位置：h&（length-1）
        主要方法：put和get方法
        put方法：首先查找其对应的hash值和index，如果该位置为空，则直接插入，若不为空，寻找相等的key，如果有则替换，否则插入到链表尾部。同时需要考虑
                扩容的情况
        get方法：直接获取
        为什么数组的长度要是2的整次幂？首先其计算位置的方法为h&（length-1），这样可以保证数据的均匀分布，从而减少哈希冲突。
                                    另外这样可以保证在扩容时，只有最高位的不同，因此可以保证散列均分分布。
        如何减少哈希冲突？2的整次幂，抖动函数，尽可能使用封装类，他们是不可变的，有固定的hash值和length。
        JDK1.8使用的是数组+链表+红黑树，同时抖动函数发生变化，直接高十六位和低十六位进行异或。
        1.7和1.8中的区别：
        （1）数据结构：前者是数组+链表，后者是数组+链表+红黑树。当链表深度达到阈值（8）时就将链表转化为红黑树。同时插入方法为尾插法，而前者是头插法，会导致死循环。
        （2）抖动函数的不同
        （3）扩容后的数据存储位置的计算不同：前者是直接将hash值与扩容后的二进制数进行&操作，而后者则是判断新增的参与运算的位是0还是1.
  注：重写equals方法为什么一定要重写hashcode方法？因为在java编程中规定，如果两个对象的equals判断为真，那么他们的hashcode值一定相同。
  线程不安全：为什么？多线程时采用头插法可能会导致死循环
  允许null键和值
  HashTable：不允许null值，线程安全，初始容量11，扩容2x+1，计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length，效率较低。rehash方法
2. TreeMap底层实现：
红黑树基本概念：
五个要求：（1）每个节点只能是红色或者黑色（2）根节点是黑色的（3）每个叶节点（NIL节点，空节点）都是黑色的（4）一个节点如果是红色的，其两个字节点都是黑色的。
（5）从任一节点到其每个叶子节点的所有路径上的黑色节点数目相同。
基本操作：旋转和着色。
TreeMap的底层结构是红黑树，同时是有序的，因为其内部有一个Comparator的比较器，可以实现比较和排序。
put方法
put：分为两步，构建二叉排序数和平衡二叉树。
3.JVM
Java的内存区域：分为堆和栈，栈（私有）中包括PC，虚拟机栈（栈帧，局部变量表，操作数，动态链接等信息）和本地方法栈（Native方法，java调用的非java代码）
堆（共享）主要包含堆（创建实例对象）、方法区（存储已被VM加载的类信息、常量、静态变量和即时编译信息），运行时常量池（将方法区中的常量池内容加载到运行时常量池
主要是字面量和符号引用，其中符号引用主要是tag和index的字符串结构）
类的生命周期：类加载--验证--准备--解析--初始化--使用--卸载。
